---
# REQUIRED FIELDS
title: "Understanding CKB Lock Value Relationships"
slug: "understanding-ckb-lock-value-relationships"
permalink: /posts/{{ slug }}/
date: 2025-09-10
layout: layouts/post.njk

# STANDARD FIELDS  
tags: ["post", "lock-script", "addresses", "cryptography", "keys", "scripts", "smart-contracts"]
author: "Jordan Mack"
id: "lock-value-relationships"  # Used for image folder: /assets/images/posts/lock-value-relationships/

# OPTIONAL FIELDS
# pinned: true  # Uncomment to pin post
# updated: 2025-09-10  # Only add when post is actually updated
---

In CKB smart contract development, understanding how different lock-related values connect to each other is crucial. These values form a chain of cryptographic relationships that govern cell ownership, address generation, and transaction verification.

## The Complete Value Derivation Chain

Here's how all lock-related values connect in CKB:

```
Private Key (32 bytes)
    ↓ secp256k1 elliptic curve
Public Key (33 bytes, compressed)
    ↓ ckbhash, truncate to 20 bytes (blake160)
Lock Arg (20 bytes)
    ↓ combine with code_hash + hash_type
Lock Script (structure)
    ↓ ckbhash of molecule-serialized script
Lock Hash (32 bytes)
    ↓ bech32m encoding with prefix
Address (human-readable string)
```

Each step in this chain serves a specific purpose and follows well-defined cryptographic standards.

## Understanding Each Value

### Private Key (32 bytes)
The foundation of everything - your secret that must never be shared:

```javascript
const privateKey = "0xd00c06bfd800d27397002dca6fb0993d5ba6399b4238b2f29ee9deb97593d2bc";
// 32 bytes of entropy that controls all derived values
```

### Public Key (33 bytes)
Derived from the private key using secp256k1 elliptic curve cryptography:

```javascript
import secp256k1 from "secp256k1";

const publicKey = secp256k1.publicKeyCreate(hexToUint8Array(privateKey));
// Results in 33-byte compressed public key
// Example: "0x024a501efd328e062c8675f2365970728c859c592beeefd6be8ead3d901330bc01"
```

The public key can be shared freely - it proves identity without revealing the private key.

### Lock Arg (20 bytes)
Generated by applying ckbhash to the public key and taking the first 20 bytes (blake160):

```javascript
import {ckbHash} from "@ckb-lumos/base";

const lockArg = ckbHash(publicKey).substring(0, 42); // 0x + 40 hex chars = 20 bytes
// Example: "0xb39bbc0b3673c7d36450bc14cfcdad2d559c6c64"
```

This becomes the `args` field in your lock script and uniquely identifies your "account."

### Lock Script (structure)
The complete script structure that defines cell ownership:

```javascript
const lockScript = {
	codeHash: "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
	hashType: "type",
	args: lockArg // Your 20-byte identifier
};
```

**Key components:**
- **codeHash**: Points to the lock script code (shared by all users of this lock type)
- **hashType**: How to locate the script (`type` for default lock)
- **args**: Your unique identifier (the lock arg from your public key)

### Lock Hash (32 bytes)
A unique identifier for the complete lock script, calculated by:

```javascript
import {computeScriptHash} from "@ckb-lumos/base";

const lockHash = computeScriptHash(lockScript);
// This performs: ckbhash(molecule_encode(lockScript))
// Example: "0x1f2615a8dde4e28ca736ff763c2078aff990043f4cbf09eb4b3a58a140a0862d"
```

### Address (human-readable)
The user-friendly representation of your lock script:

```javascript
import {encodeToAddress} from "@ckb-lumos/helpers";

const address = encodeToAddress(lockScript);
// Example: "ckt1qzda0cr08m85hc8jlnfp3zer7xulejywt49kt2rr0vthywaa50xwsqwgx292hnvmn68xf779vmzrshpmm6epn4c0cgwga"
```

The address encodes the entire lock script in a format that's easy to share and verify.

## Lock Script Structure Deep Dive

### Code Hash and Hash Type Relationship

The combination of `codeHash` and `hashType` determines how CKB locates the script code:

```javascript
// Default lock script
{
	codeHash: "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
	hashType: "type", // Look for a cell with this type script hash
	args: "0x..."     // Your unique parameters
}
```

**Hash Type Values:**
- **`type`**: Locate script by matching a cell's type script hash
- **`data`/`data1`/`data2`**: Locate script by matching cell data hash directly

### Args Field: The Key to Uniqueness

The `args` field is what makes each lock script unique:

```javascript
// Same code_hash, different args = different users
const userA = {
	codeHash: "0x9bd7e06f...",
	hashType: "type",
	args: "0xuser_a_lock_arg..."
};

const userB = {
	codeHash: "0x9bd7e06f...", // Same script code
	hashType: "type",
	args: "0xuser_b_lock_arg..." // Different user
};
```

This design allows thousands of users to share the same lock script code while maintaining unique identities.

## Practical Code Example

Here's a complete example showing all transformations:

```javascript
import secp256k1 from "secp256k1";
import {ckbHash, computeScriptHash} from "@ckb-lumos/base";
import {encodeToAddress} from "@ckb-lumos/helpers";
import {hexToUint8Array, uint8ArrayToHex} from "./util.js";

// 1. Start with private key
const privateKey = "0xd00c06bfd800d27397002dca6fb0993d5ba6399b4238b2f29ee9deb97593d2bc";
console.log(`Private Key: ${privateKey} (32 bytes)`);

// 2. Generate public key
const publicKey = uint8ArrayToHex(secp256k1.publicKeyCreate(hexToUint8Array(privateKey)));
console.log(`Public Key: ${publicKey} (33 bytes)`);

// 3. Create lock arg (blake160)
const lockArg = ckbHash(publicKey).substring(0, 42);
console.log(`Lock Arg: ${lockArg} (20 bytes)`);

// 4. Build lock script
const lockScript = {
	codeHash: "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
	hashType: "type",
	args: lockArg
};
console.log(`Lock Script:`, lockScript);

// 5. Calculate lock hash
const lockHash = computeScriptHash(lockScript);
console.log(`Lock Hash: ${lockHash} (32 bytes)`);

// 6. Generate address
const address = encodeToAddress(lockScript);
console.log(`Address: ${address}`);
```

## Why These Relationships Matter

### 1. Ownership Verification
The lock script hash uniquely identifies who owns a cell. During transaction validation, CKB:
1. Extracts the lock script from the cell
2. Calculates its hash
3. Groups all inputs with the same lock script hash
4. Runs the lock script once per group to verify signatures

### 2. Address Generation
Addresses are just human-readable encodings of lock scripts:
- Same lock script = same address
- Different args = different address
- Portable across different applications

### 3. Script Reusability
The code_hash + args pattern enables efficient script reuse:
- One script code serves thousands of users
- Each user has unique args (derived from their public key)
- Reduces on-chain storage requirements

### 4. Cross-Reference Capability
Other scripts can reference your lock script by its hash:
- Type scripts can check lock script ownership
- Multi-sig contracts can verify participant locks
- Enables complex smart contract interactions

## Common Use Cases

### Verifying Cell Ownership
```javascript
// Check if a cell belongs to a specific address
const cellLockHash = computeScriptHash(cell.cellOutput.lock);
const expectedLockHash = computeScriptHash(addressToScript(myAddress));

if (cellLockHash === expectedLockHash) {
	console.log("This cell belongs to me!");
}
```

### Creating Unique Script Instances
```javascript
// Same lock code, different users
function createUserLock(userPublicKey) {
	const lockArg = ckbHash(userPublicKey).substring(0, 42);
	return {
		codeHash: DEFAULT_LOCK_CODE_HASH,
		hashType: "type",
		args: lockArg
	};
}
```

### Address Validation
```javascript
// Convert address back to lock script and verify
function validateAddress(address) {
	try {
		const lockScript = addressToScript(address);
		const reconstructedAddress = encodeToAddress(lockScript);
		return address === reconstructedAddress;
	} catch (error) {
		return false;
	}
}
```

## Security Considerations

### Private Key Protection
- Never log, transmit, or store private keys in plain text
- Use secure key derivation for HD wallets
- Consider hardware wallet integration for production

### Lock Arg Uniqueness
- Blake160 provides 160 bits of security (collision resistance)
- Probability of collision is negligible for practical purposes
- Always verify lock args during development

### Script Hash Verification
- Always verify script hashes when referencing locks
- Don't assume script structure - validate it
- Be aware that different script structures can have the same functionality

## Conclusion

Understanding CKB lock value relationships is fundamental to smart contract development. The chain from private key to address creates a robust system of ownership, identity, and verification. Each value serves a specific purpose:

- **Private Key**: Your secret authority
- **Public Key**: Your public identity  
- **Lock Arg**: Your unique identifier
- **Lock Script**: Your complete ownership specification
- **Lock Hash**: Your script's unique fingerprint
- **Address**: Your human-readable identifier

Mastering these relationships will make you more effective at building, debugging, and securing CKB applications.